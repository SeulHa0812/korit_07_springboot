### 1. 개발 환경 & 도구
1. IntelliJ 설치 : 주로 Java/Spring 개발에 쓰는 IDE.
2. Gradle : 빌드/의존성 관리 툴.  
  2-1. Maven도 대안이지만, 가시성이 좋은 Gradle을 사용.  
  2-2. build.gradle 파일을 통해 프로젝트 설정을 관리.  
  2-3. Groovy 언어 기반으로 작성 (Kotlin도 가능).

### 2. Gradle의 핵심 구성
-  일반적인 build.gradle 내부의 항목 :
1. plugins : 사용할 플러그인 정의 (예: spring-boot, lombok).
2. repositories : 외부 라이브러리를 어디서 가져올지 지정 (보통 Maven Central).
3. dependencies : 실제 사용할 라이브러리 정의.
4. tasks : 빌드, 테스트, 실행 같은 작업 정의.

👉 쉽게 말해, build.gradle은 이 프로젝트가 어떤 환경에서 어떤 라이브러리를 써서 빌드될지 알려주는 설명서.

## 3. Spring Initializr

https://start.spring.io
 에서 빠르게 Spring Boot 프로젝트를 생성 가능.  

주요 의존성 예시:

Spring Web : 웹 애플리케이션 기본 설정 제공.

Spring Boot DevTools : 코드 수정 시 자동 재시작 지원 → 개발 편리성 ↑.

## 4. @SpringBootApplication 애너테이션

Spring Boot의 핵심 진입점에 붙는 애너테이션.  

실제로는 3개가 합쳐진 것:

1. @EnableAutoConfiguration : 의존성에 따라 자동 설정.

2. @ComponentScan : 컴포넌트 스캔으로 Bean 검색.

3. @Configuration : Bean 설정 클래스임을 명시.

즉, 개발자가 별도 설정을 다 하지 않아도 기본적인 환경이 자동 세팅됨.

## 5. Logging (로깅)

- Logback이 기본 탑재됨.

- 인터페이스는 SLF4J.

- 로그 수준 : TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
  - 기본은 INFO 수준.

- application.properties 에서 로그 레벨을 조절 가능.

예시:
```java
import org.slf4j.Logger; // 로거 인터페이스
import org.slf4j.LoggerFactory; // 로거 객체를 만드는 팩토리 클래스
import org.springframework.boot.SpringApplication; // 스프링 부트 애플리케이션 실행
import org.springframework.boot.autoconfigure.SpringBootApplication; // 애플리케이션 시작점 annotation

@SpringBootApplication
public class CardatabaseApplication {
	private static final Logger logger = LoggerFactory.getLogger(
			CardatabaseApplication.class
	);

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started ! / 애플리케이션이 실행되었습니다.");
	}

}
```
Line#60 @SpringBootApplication  
→ 이 클래스가 스프링 부트 프로젝트의 시작점임을 의미.  
→ 내부적으로 컴포넌트 스캔, 자동설정, Bean 등록 시작.

Line#62 private static final Logger logger ...  
→ CardatabaseApplication 클래스 전용 로거 객체 생성.  
→ static final: 프로그램 시작 시 한 번만 만들고, 바뀌지 않음.  

Line#66 public static void main(String[] args)  
→ 자바 프로그램의 시작점.  
→ 여기서 SpringApplication.run(...)을 호출하면  

1. 스프링 컨테이너(ApplicationContext) 생성
2. Bean 등록
3. 내장 톰캣 서버 띄우기(port 8080)
4. 웹 애플리케이션 실행
  - logger.info("...")  
→ 앱이 성공적으로 실행되었음을 INFO 레벨 로그로 출력.

👉 개발 시에는 DEBUG나 INFO를 많이 쓰고, 운영 시에는 WARN이나 ERROR 위주로 확인.

---
? 스프링 컨테이너  

역할 :    

1-1. 객체 생성 (Bean 생성)  
@Component, @Service, @Repository, @Controller 같은 애너테이션이 붙은 클래스를 찾아 객체(Bean)를 만듦.

1-2. 의존성 주입   
필요한 객체를 서로 연결시켜줌.  
예: CarService가 CarRepository를 필요로 하면 자동으로 넣어줌(@Autowired).

1-3. 생명주기 관리  
객체 생성 → 초기화 → 사용 → 소멸 과정 전체를 관리.  
개발자가 new 해서 직접 생성/소멸 관리하지 않아도 됨.  

1-4. 설정/환경 관리  
application.properties 같은 설정값도 컨테이너가 Bean에 주입해줌.



👉 스프링에서 말하는 Bean = 스프링 컨테이너가 관리하는 객체예요.

1. 일반 객체 vs Bean

- 일반 객체 : new 키워드로 개발자가 직접 생성  

  생명주기(생성 → 사용 → 소멸)를 개발자가 관리  

- Bean : 스프링 컨테이너(ApplicationContext)가 생성하고 관리하는 객체  

  컨테이너가 알아서 싱글톤 관리, 의존성 주입(DI), 생명주기 관리를 해줌  

2. Bean 등록 방법

  - 스프링이 어떤 객체를 Bean으로 관리할지는 어노테이션이나 설정 클래스로 알려줍니다.

어노테이션 기반
```
@Service
public class CarService { ... }

@Repository
public class CarRepository { ... }

@Controller
public class CarController { ... }

```
직접 Bean 등록
```
@Configuration
public class AppConfig {
    @Bean
    public CarService carService() {
        return new CarService();
    }
}
```
```
현재 port 구성
Springboot : 8080
MariaDB : 3310
으로 기억
```
---
## 6. 의존성 주입(Dependency Injection)의 개념

- 정의 : 한 클래스(클라이언트)가 다른 클래스(서비스)에 의존할 때, 직접 객체를     만들지 않고 외부에서 전달받아 사용하는 개발 기법.

- 목적 :

  - 클래스 간 결합도를 낮춤(Loose coupling).

  - 코드 재사용성, 테스트 용이성 향상(Mock 객체 주입 가능).

- 구성 요소 :

  - Service : 의존성을 제공하는 클래스 (예: Owner, Repository).

  - Client : 의존성을 사용하는 클래스 (예: Car).

  - Injector : 의존성을 생성하고 클라이언트에 전달하는 주체 (Spring ApplicationContext).

👉 즉, **"필요한 건 외부에서 넣어주겠다"**는 개념.

## 6-1. 자바 코드에서 DI 비교
❌ 직접 생성(의존성 주입 X)
```java
public class Car {
    private Owner owner;

    public Car() {
        this.owner = new Owner(); // Car가 직접 Owner를 생성
    }
}
```
➡ Car와 Owner가 강하게 결합 → 테스트, 교체 어려움.

✅ 생성자 주입(의존성 주입 O)
```java
public class Car {
    private Owner owner;

    public Car(Owner owner) { // 외부에서 Owner를 받아옴
        this.owner = owner;
    }
}
```
➡ Car는 Owner 객체를 스스로 만들지 않고 외부에서 전달받음 → 유연성 ↑, 테스트 용이.

## 6-2. 의존성 주입 유형

1. 생성자 주입 (Constructor Injection)

- 필수 의존성에 권장.

- 객체 생성 시 의존성을 반드시 제공해야 함.
```java
public class Car {
    private final Owner owner; // 반드시 필요 -> final

    public Car(Owner owner) { // Car 만들 때 무조건 Owner 줘야 함
        this.owner = owner;
    }
}
```

2. 세터 주입 (Setter Injection)

- 선택적 의존성에 적합.

- 객체 생성 후 필요할 때 의존성을 세팅.
```java
public class Car {
    private Owner owner;

    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}
```

3. 필드 주입 (Field Injection)

- 가장 단순하지만 테스트 어려움 → 최근에는 권장되지 않음.
```java
public class Car {
    @Autowired
    private Owner owner; // 바로 컨테이너에서 주입
}
```

## 6-3. 스프링 부트에서의 DI

Spring ApplicationContext 가 Bean(객체)을 생성·관리하고, 필요한 곳에 의존성을 주입.

특정 애너테이션(@Service, @Repository, @Controller 등)이 붙은 클래스는 자동으로 Spring Bean으로 등록됨.

### (1) 생성자 주입 (권장 방식)
```java
@Service
public class CarService {
    private final CarRepository carRepository;

    @Autowired // 생성자가 하나면 생략 가능
    public CarService(CarRepository carRepository) {
        this.carRepository = carRepository;
    }

    public void getCars() {
        carRepository.findAll(); // DB에서 모든 Car 조회
    }
}
```

👉 장점

객체 불변성 보장(final 필드).

테스트 시 Mock 주입 용이.

의존성 없이는 객체 생성 불가 → 안전성 ↑.

### (2) 세터 주입
```java
@Service
public class AppUserService {
    private AppUserRepository userRepository;

    @Autowired
    public void setAppUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public long countUsers() {
        return userRepository.count();
    }
}
```

👉 장점

런타임에 의존성 교체 가능.

선택적 의존성 처리에 유리.
👉 단점

불변성 보장 X.

### (3) 필드 주입
```
@Controller
public class CarController {
    @Autowired
    private CarService carService;

    @GetMapping("/cars")
    public List<Car> getCars() {
        return carService.getCars();
    }
}
```

👉 장점 : 코드 간결.
👉 단점 : 테스트, Mock 주입 어려움 → 최근에는 잘 안 씀.